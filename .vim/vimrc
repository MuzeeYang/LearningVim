"source ~/.vim/.earthmelon.vim
syntax on
set mouse=a
set hlsearch nowrapscan scrolloff=7 number smartindent tabstop=4 softtabstop=4 shiftwidth=4 "expandtab 
set fileencodings=ucs-bom,utf-8,cp20932,cp51932,cp932,cp20936,cp51936,cp54936,cp936,cp950,latin1
let mapleader="`"

"set auto pair
:vnoremap () c()<esc>hpl
:vnoremap [] c[]<esc>hpl
:vnoremap "" c""<esc>hpl
:vnoremap {} c{}<esc>hpl
:vnoremap '' c''<esc>hpl
:vnoremap <> c<><esc>hpl
:vnoremap {{ c{<cr>}<esc>Pvi{>
:nnoremap X :call ErasePire()<cr>

"save file
:nnoremap <leader>s :call SaveFile()<cr>

"set tab to compeletion
:inoremap <tab> <c-r>=TabComplete()<cr>
:inoremap <leader><tab> <tab>
:nnoremap <tab> <c-w>w

"space select
:nnoremap <space> viw
:vnoremap <space> e
:inoremap <leader><space> <c-r>=EmptyPairsJmp()<cr>
:nnoremap <leader><space> :call AllPairsJmp()<cr>
:vnoremap <leader><space> <esc>:call AllPairsJmp()<cr>

"search highlight
:vnoremap y "py
:vnoremap p "pp
:vnoremap f "fy:call FindSearchItem()<cr>

"set fold
:set foldmethod=syntax
:set nofoldenable
:nnoremap <F4> :set foldenable!<cr>:set foldenable?<cr>
:nnoremap = zo
:nnoremap - zc
:nnoremap + zO
:nnoremap _ zC

"ctags
:nnoremap <leader>] <c-]> 
:nnoremap <leader>} g] 
:nnoremap <leader>[ <c-t> 

"switch upper/lower
:inoremap <leader>~ <esc>viw~ea

"scroll page
:nnoremap , <c-w>7<
:nnoremap . <c-w>7>
:nnoremap <c-j> <c-d>
:nnoremap <c-k> <c-u>
:inoremap <c-h> <left>
:inoremap <c-l> <right>
:inoremap <c-j> <down>
:inoremap <c-k> <up>

"split
:nnoremap U <c-t>
:nnoremap S cw
:inoremap `` `


"status line
set cursorline
set laststatus=2
set statusline=%1*\ %f%h%r%m\ %*\ %<[%{&ft}][%{&ff}]%=%l,%02c%7p%%\ 
hi	user1				term=bold			cterm=bold
hi	user1				ctermfg=white		ctermbg=red
hi	statuslinenc		term=bold			cterm=bold
hi	statuslinenc		ctermfg=black		ctermbg=grey
hi	statusline			term=bold			cterm=bold
hi	statusline			ctermfg=black		ctermbg=white

augroup colors_earthmelon
	:autocmd!
	:autocmd InsertEnter * :execute ":hi user1 ctermfg=white ctermbg=darkblue"
	:autocmd InsertLeave * :execute ":hi user1 ctermfg=white ctermbg=red"
augroup end

"autocmd
augroup auto_buffer
	:autocmd!
	:autocmd filetype c,cpp :set cindent
	:autocmd filetype c,cpp :set tags=./ctags,~/ctags,~/.vim/systags
	:autocmd bufreadpre,bufnewfile * :source ~/.vim/syntax/common.vim
	:autocmd bufreadpost,bufread * :normal! '"
	:autocmd TextChanged,TextChangedI * :let g:LNO = -1
augroup end

"Functions
let g:LNO = -1
let g:PAIRS = []
let g:PCS = 0

function! TabComplete()
	let s:lineStr = getline('.')
	let s:posCur = col('.')

	if s:posCur == len(s:lineStr) + 1 "pos at the end
		let s:endKeyWord = match(s:lineStr, "[0-9a-zA-Z_]$", s:posCur - 2)
	else
		let s:endKeyWord = match(s:lineStr, "[0-9a-zA-Z_][^0-9a-zA-Z_]", s:posCur - 2)
	endif
	if s:endKeyWord != -1
		if s:endKeyWord == s:posCur - 2
			return "\<c-n>"
		endif
	endif
	return "\<tab>"

endfunction

function! EmptyPairsJmp()
	let s:startSearch = col('.')
	let s:lineSearch = getline('.')
	let s:rangeSearch = len(s:lineSearch)
	if s:startSearch > s:rangeSearch
		let s:startSearch = 1
	endif

	let s:pattenPairs = '()\|[]\|{}\|""\|<>\|'''''
	let s:startSearch = match(s:lineSearch,s:pattenPairs,s:startSearch - 1)
	if s:startSearch != -1
		call cursor(0,s:startSearch + 1)
	else
		call cursor(0,s:rangeSearch + 1)
	endif
	return "\<right>"
endfunction

function! FindSearchItem()
	let @/=@f
endfunction

function! SaveFile()
	if &readonly == 1 "readonly
		let s:isSaveForce = input("This file is [RO], SAVE it by force or not (y/n)?")
		if s:isSaveForce == 'y'
			:w !sudo tee % >/dev/null
		endif
	else "noreadonly
		:w
	endif
endfunction

function! AllPairsJmp()
	let s:lno = line('.')
	if s:lno != g:LNO		" same line do nothing
		let g:LNO = s:lno
		call GetLinePairs()
	endif

	let s:plength = len(g:PAIRS)
	let s:vldidx = g:PCS
	while s:vldidx < s:plength
		if len(g:PAIRS[s:vldidx]) == 3			" pairs complete
			break
		endif
		let s:vldidx = s:vldidx + 1
	endwhile

	let g:PCS = s:vldidx + 1		" update pcs
	if g:PCS >= s:plength
		let g:PCS = 0
	endif

	if s:vldidx == s:plength		" empty pairs or all invilid pairs
		return
	endif

	if g:PAIRS[s:vldidx][1] + 1 == g:PAIRS[s:vldidx][2]			" empty pairs
		call cursor(0, g:PAIRS[s:vldidx][2]+1)
		":normal! i
	else
		call cursor(0, g:PAIRS[s:vldidx][2])
		execute ":normal! vi".g:PAIRS[s:vldidx][0]
	endif
endfunction

function! GetLinePairs()
	let g:PAIRS = []
	let g:PCS = 0
	let s:lline = getline('.')
	let s:idx = 0
	let s:llength = len(s:lline)
	let s:isInStr = 0		" flag for \",\'
	while s:idx < s:llength
		if s:lline[s:idx] == '\'
			let s:idx = s:idx + 1
		elseif s:lline[s:idx] == '"'
			call DealDaulQua(s:lline[s:idx], s:idx)
		elseif s:lline[s:idx] == "'"
			call DealSingQua(s:lline[s:idx], s:idx)
		elseif s:isInStr != 0		" if cursor in the \"\" or \'\', do not detect others
			"echo 'do nothing'
		elseif s:lline[s:idx] == '{' || s:lline[s:idx] == '}'
			call DealBigQua(s:lline[s:idx], s:idx)
		elseif s:lline[s:idx] == '[' || s:lline[s:idx] == ']'
			call DealMidQua(s:lline[s:idx], s:idx)
		elseif s:lline[s:idx] == '(' || s:lline[s:idx] == ')'
			call DealLittQua(s:lline[s:idx], s:idx)
		elseif s:lline[s:idx] == '<' || s:lline[s:idx] == '>'
			call DealTipQua(s:lline[s:idx], s:idx)
		endif
		let s:idx = s:idx + 1
	endwhile
	echo g:PAIRS
endfunction

function! DealBigQua(ch, idx)
	if a:ch == '{'
		call add(g:PAIRS, [a:ch, a:idx])
	else
		let s:pairCursor = len(g:PAIRS)
		while s:pairCursor > 0
			let s:pairCursor = s:pairCursor - 1
			if len(g:PAIRS[s:pairCursor]) == 2 && g:PAIRS[s:pairCursor][0] == '{'
				call add(g:PAIRS[s:pairCursor], a:idx)
				break
			endif
		endwhile
	endif
endfunction

function! DealMidQua(ch, idx)
	if a:ch == '['
		call add(g:PAIRS, [a:ch, a:idx])
	else
		let s:pairCursor = len(g:PAIRS)
		while s:pairCursor > 0
			let s:pairCursor = s:pairCursor - 1
			if len(g:PAIRS[s:pairCursor]) == 2 && g:PAIRS[s:pairCursor][0] == '['
				call add(g:PAIRS[s:pairCursor], a:idx)
				break
			endif
		endwhile
	endif
endfunction

function! DealLittQua(ch, idx)
	if a:ch == '('
		call add(g:PAIRS, [a:ch, a:idx])
	else
		let s:pairCursor = len(g:PAIRS)
		while s:pairCursor > 0
			let s:pairCursor = s:pairCursor - 1
			if len(g:PAIRS[s:pairCursor]) == 2 && g:PAIRS[s:pairCursor][0] == '('
				call add(g:PAIRS[s:pairCursor], a:idx)
				break
			endif
		endwhile
	endif
endfunction

function! DealTipQua(ch, idx)
	if a:ch == '<'
		call add(g:PAIRS, [a:ch, a:idx])
	else
		let s:pairCursor = len(g:PAIRS)
		while s:pairCursor > 0
			let s:pairCursor = s:pairCursor - 1
			if len(g:PAIRS[s:pairCursor]) == 2 && g:PAIRS[s:pairCursor][0] == '<'
				call add(g:PAIRS[s:pairCursor], a:idx)
				break
			endif
		endwhile
	endif
endfunction

function! DealDaulQua(ch, idx)
	if s:isInStr != 0 && s:isInStr != 2
		return
	endif

	let s:pairCursor = len(g:PAIRS) - 1
	while s:pairCursor >= 0
		if len(g:PAIRS[s:pairCursor]) == 2 && g:PAIRS[s:pairCursor][0] == '"'
			call add(g:PAIRS[s:pairCursor], a:idx)
			let s:isInStr = 0
			break
		endif
		let s:pairCursor = s:pairCursor - 1
	endwhile
	if s:pairCursor < 0
		call add(g:PAIRS, [a:ch, a:idx])
		let s:isInStr = 2
	endif
endfunction

function! DealSingQua(ch, idx)
	if s:isInStr != 0 && s:isInStr != 1
		return
	endif

	let s:pairCursor = len(g:PAIRS) - 1
	while s:pairCursor >= 0
		if len(g:PAIRS[s:pairCursor]) == 2 && g:PAIRS[s:pairCursor][0] == "'"
			call add(g:PAIRS[s:pairCursor], a:idx)
			let s:isInStr = 0
			break
		endif
		let s:pairCursor = s:pairCursor - 1
	endwhile
	if s:pairCursor < 0
		call add(g:PAIRS, [a:ch, a:idx])
		let s:isInStr = 1
	endif
endfunction

function! ErasePairs()
	let s:lno = line('.')
	if s:lno != g:LNO		" same line do nothing
		let g:LNO = s:lno
		call GetLinePairs()
	endif

	let s:curPos = col('.') - 1
	for s:tpair in g:PAIRS
		if len(s:tpair) != 3
			continue
		endif

		if s:tpair[1] == s:curPos
			:normal! r 
			call cursor(0, s:tpair[2]+1)
			:normal! r 
			return
		elseif s:tpair[2] == s:curPos
			:normal! r 
			call cursor(0, s:tpair[1]+1)
			:normal! r 
			return
		endif
	endfor

	:normal! x
endfunction

"beta debug
:nnoremap <leader>rr :source $MYVIMRC<cr>
:nnoremap <leader>tt :call TestFunc()<cr>
iabbrev waht what
augroup autest
	:autocmd!
augroup end

